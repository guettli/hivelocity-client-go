/*
Hivelocity API

Interact with Hivelocity

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// BandwidthApiService BandwidthApi service
type BandwidthApiService service

type ApiPostDeviceIdBandwidthImageResourceRequest struct {
	ctx        context.Context
	ApiService *BandwidthApiService
	deviceId   int32
	period     *string
	interface_ *string
	start      *int32
	end        *int32
	xFields    *string
}

// Return data in the given period. Day, week, month will return the previous day, week, month from now.
func (r ApiPostDeviceIdBandwidthImageResourceRequest) Period(period string) ApiPostDeviceIdBandwidthImageResourceRequest {
	r.period = &period
	return r
}

// Network interface to get bandwidth usage from. eth0 and eth1 are your first and second nic respectively. If unsure use the public, private, and all values. Overages are billed on public traffic.
func (r ApiPostDeviceIdBandwidthImageResourceRequest) Interface_(interface_ string) ApiPostDeviceIdBandwidthImageResourceRequest {
	r.interface_ = &interface_
	return r
}

// Start Time of Custom Time Period. (Unix Epoch Time)
func (r ApiPostDeviceIdBandwidthImageResourceRequest) Start(start int32) ApiPostDeviceIdBandwidthImageResourceRequest {
	r.start = &start
	return r
}

// End Time of Custom Time Period (Unix Epoch Time)
func (r ApiPostDeviceIdBandwidthImageResourceRequest) End(end int32) ApiPostDeviceIdBandwidthImageResourceRequest {
	r.end = &end
	return r
}

// An optional fields mask
func (r ApiPostDeviceIdBandwidthImageResourceRequest) XFields(xFields string) ApiPostDeviceIdBandwidthImageResourceRequest {
	r.xFields = &xFields
	return r
}

func (r ApiPostDeviceIdBandwidthImageResourceRequest) Execute() ([]BandwidthImage, *http.Response, error) {
	return r.ApiService.PostDeviceIdBandwidthImageResourceExecute(r)
}

/*
PostDeviceIdBandwidthImageResource Get PNG by device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId ID of Device to View
 @return ApiPostDeviceIdBandwidthImageResourceRequest
*/
func (a *BandwidthApiService) PostDeviceIdBandwidthImageResource(ctx context.Context, deviceId int32) ApiPostDeviceIdBandwidthImageResourceRequest {
	return ApiPostDeviceIdBandwidthImageResourceRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//  @return []BandwidthImage
func (a *BandwidthApiService) PostDeviceIdBandwidthImageResourceExecute(r ApiPostDeviceIdBandwidthImageResourceRequest) ([]BandwidthImage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BandwidthImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BandwidthApiService.PostDeviceIdBandwidthImageResource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bandwidth/device/{deviceId}/image"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}
	if r.interface_ == nil {
		return localVarReturnValue, nil, reportError("interface_ is required and must be specified")
	}

	localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	localVarQueryParams.Add("interface", parameterToString(*r.interface_, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xFields != nil {
		localVarHeaderParams["X-Fields"] = parameterToString(*r.xFields, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDeviceIdBandwidthResourceRequest struct {
	ctx        context.Context
	ApiService *BandwidthApiService
	deviceId   int32
	period     *string
	interface_ *string
	step       *int32
	historical *bool
	start      *int32
	end        *int32
	xFields    *string
}

// Return data in the given period. Day, week, month will return the previous day, week, month from now.
func (r ApiPostDeviceIdBandwidthResourceRequest) Period(period string) ApiPostDeviceIdBandwidthResourceRequest {
	r.period = &period
	return r
}

// Network interface to get bandwidth usage from. eth0 and eth1 are your first and second nic respectively. If unsure use the public, private, and all values. Overages are billed on public traffic.
func (r ApiPostDeviceIdBandwidthResourceRequest) Interface_(interface_ string) ApiPostDeviceIdBandwidthResourceRequest {
	r.interface_ = &interface_
	return r
}

// Interval of data in seconds. Historical data is condensed, if provided value is smaller than existing steps for the date range the endpoint will return data with the smallest available step.
func (r ApiPostDeviceIdBandwidthResourceRequest) Step(step int32) ApiPostDeviceIdBandwidthResourceRequest {
	r.step = &step
	return r
}

// If you are a reseller, this will include historical interface data for device regardless of the current device owner.
func (r ApiPostDeviceIdBandwidthResourceRequest) Historical(historical bool) ApiPostDeviceIdBandwidthResourceRequest {
	r.historical = &historical
	return r
}

// Start time of custom time period. (Unix Epoch Time)
func (r ApiPostDeviceIdBandwidthResourceRequest) Start(start int32) ApiPostDeviceIdBandwidthResourceRequest {
	r.start = &start
	return r
}

// End time of custom time period (Unix Epoch Time)
func (r ApiPostDeviceIdBandwidthResourceRequest) End(end int32) ApiPostDeviceIdBandwidthResourceRequest {
	r.end = &end
	return r
}

// An optional fields mask
func (r ApiPostDeviceIdBandwidthResourceRequest) XFields(xFields string) ApiPostDeviceIdBandwidthResourceRequest {
	r.xFields = &xFields
	return r
}

func (r ApiPostDeviceIdBandwidthResourceRequest) Execute() ([]Bandwidth, *http.Response, error) {
	return r.ApiService.PostDeviceIdBandwidthResourceExecute(r)
}

/*
PostDeviceIdBandwidthResource Get data by device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deviceId ID of Device to View
 @return ApiPostDeviceIdBandwidthResourceRequest
*/
func (a *BandwidthApiService) PostDeviceIdBandwidthResource(ctx context.Context, deviceId int32) ApiPostDeviceIdBandwidthResourceRequest {
	return ApiPostDeviceIdBandwidthResourceRequest{
		ApiService: a,
		ctx:        ctx,
		deviceId:   deviceId,
	}
}

// Execute executes the request
//  @return []Bandwidth
func (a *BandwidthApiService) PostDeviceIdBandwidthResourceExecute(r ApiPostDeviceIdBandwidthResourceRequest) ([]Bandwidth, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Bandwidth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BandwidthApiService.PostDeviceIdBandwidthResource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bandwidth/device/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterToString(r.deviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}
	if r.interface_ == nil {
		return localVarReturnValue, nil, reportError("interface_ is required and must be specified")
	}
	if r.step == nil {
		return localVarReturnValue, nil, reportError("step is required and must be specified")
	}

	localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	localVarQueryParams.Add("interface", parameterToString(*r.interface_, ""))
	if r.historical != nil {
		localVarQueryParams.Add("historical", parameterToString(*r.historical, ""))
	}
	localVarQueryParams.Add("step", parameterToString(*r.step, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xFields != nil {
		localVarHeaderParams["X-Fields"] = parameterToString(*r.xFields, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostServiceIdBandwidthImageResourceRequest struct {
	ctx        context.Context
	ApiService *BandwidthApiService
	serviceId  int32
	period     *string
	interface_ *string
	start      *int32
	end        *int32
	xFields    *string
}

// Return data in the given period. Day, week, month will return the previous day, week, month from now.
func (r ApiPostServiceIdBandwidthImageResourceRequest) Period(period string) ApiPostServiceIdBandwidthImageResourceRequest {
	r.period = &period
	return r
}

// Network interface to get bandwidth usage from. eth0 and eth1 are your first and second nic respectively. If unsure use the public, private, and all values. Overages are billed on public traffic.
func (r ApiPostServiceIdBandwidthImageResourceRequest) Interface_(interface_ string) ApiPostServiceIdBandwidthImageResourceRequest {
	r.interface_ = &interface_
	return r
}

// Start Time of Custom Time Period. (Unix Epoch Time)
func (r ApiPostServiceIdBandwidthImageResourceRequest) Start(start int32) ApiPostServiceIdBandwidthImageResourceRequest {
	r.start = &start
	return r
}

// End Time of Custom Time Period (Unix Epoch Time)
func (r ApiPostServiceIdBandwidthImageResourceRequest) End(end int32) ApiPostServiceIdBandwidthImageResourceRequest {
	r.end = &end
	return r
}

// An optional fields mask
func (r ApiPostServiceIdBandwidthImageResourceRequest) XFields(xFields string) ApiPostServiceIdBandwidthImageResourceRequest {
	r.xFields = &xFields
	return r
}

func (r ApiPostServiceIdBandwidthImageResourceRequest) Execute() ([]BandwidthImage, *http.Response, error) {
	return r.ApiService.PostServiceIdBandwidthImageResourceExecute(r)
}

/*
PostServiceIdBandwidthImageResource Get PNG by service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId ID of Service to View
 @return ApiPostServiceIdBandwidthImageResourceRequest
*/
func (a *BandwidthApiService) PostServiceIdBandwidthImageResource(ctx context.Context, serviceId int32) ApiPostServiceIdBandwidthImageResourceRequest {
	return ApiPostServiceIdBandwidthImageResourceRequest{
		ApiService: a,
		ctx:        ctx,
		serviceId:  serviceId,
	}
}

// Execute executes the request
//  @return []BandwidthImage
func (a *BandwidthApiService) PostServiceIdBandwidthImageResourceExecute(r ApiPostServiceIdBandwidthImageResourceRequest) ([]BandwidthImage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BandwidthImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BandwidthApiService.PostServiceIdBandwidthImageResource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bandwidth/service/{serviceId}/image"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}
	if r.interface_ == nil {
		return localVarReturnValue, nil, reportError("interface_ is required and must be specified")
	}

	localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	localVarQueryParams.Add("interface", parameterToString(*r.interface_, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xFields != nil {
		localVarHeaderParams["X-Fields"] = parameterToString(*r.xFields, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostServiceIdBandwidthResourceRequest struct {
	ctx        context.Context
	ApiService *BandwidthApiService
	serviceId  int32
	period     *string
	interface_ *string
	step       *int32
	start      *int32
	end        *int32
	xFields    *string
}

// Return data in the given period. Day, week, month will return the previous day, week, month from now.
func (r ApiPostServiceIdBandwidthResourceRequest) Period(period string) ApiPostServiceIdBandwidthResourceRequest {
	r.period = &period
	return r
}

// Network interface to get bandwidth usage from. eth0 and eth1 are your first and second nic respectively. If unsure use the public, private, and all values. Overages are billed on public traffic.
func (r ApiPostServiceIdBandwidthResourceRequest) Interface_(interface_ string) ApiPostServiceIdBandwidthResourceRequest {
	r.interface_ = &interface_
	return r
}

// Interval of data in seconds. Historical data is condensed, if provided value is smaller than existing steps for the date range the endpoint will return data with the smallest available step.
func (r ApiPostServiceIdBandwidthResourceRequest) Step(step int32) ApiPostServiceIdBandwidthResourceRequest {
	r.step = &step
	return r
}

// Start Time of Custom Time Period. (Unix Epoch Time)
func (r ApiPostServiceIdBandwidthResourceRequest) Start(start int32) ApiPostServiceIdBandwidthResourceRequest {
	r.start = &start
	return r
}

// End Time of Custom Time Period (Unix Epoch Time)
func (r ApiPostServiceIdBandwidthResourceRequest) End(end int32) ApiPostServiceIdBandwidthResourceRequest {
	r.end = &end
	return r
}

// An optional fields mask
func (r ApiPostServiceIdBandwidthResourceRequest) XFields(xFields string) ApiPostServiceIdBandwidthResourceRequest {
	r.xFields = &xFields
	return r
}

func (r ApiPostServiceIdBandwidthResourceRequest) Execute() ([]Bandwidth, *http.Response, error) {
	return r.ApiService.PostServiceIdBandwidthResourceExecute(r)
}

/*
PostServiceIdBandwidthResource Get data by service

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId ID of Service to View
 @return ApiPostServiceIdBandwidthResourceRequest
*/
func (a *BandwidthApiService) PostServiceIdBandwidthResource(ctx context.Context, serviceId int32) ApiPostServiceIdBandwidthResourceRequest {
	return ApiPostServiceIdBandwidthResourceRequest{
		ApiService: a,
		ctx:        ctx,
		serviceId:  serviceId,
	}
}

// Execute executes the request
//  @return []Bandwidth
func (a *BandwidthApiService) PostServiceIdBandwidthResourceExecute(r ApiPostServiceIdBandwidthResourceRequest) ([]Bandwidth, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Bandwidth
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BandwidthApiService.PostServiceIdBandwidthResource")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bandwidth/service/{serviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceId"+"}", url.PathEscape(parameterToString(r.serviceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.period == nil {
		return localVarReturnValue, nil, reportError("period is required and must be specified")
	}
	if r.interface_ == nil {
		return localVarReturnValue, nil, reportError("interface_ is required and must be specified")
	}
	if r.step == nil {
		return localVarReturnValue, nil, reportError("step is required and must be specified")
	}

	localVarQueryParams.Add("period", parameterToString(*r.period, ""))
	localVarQueryParams.Add("interface", parameterToString(*r.interface_, ""))
	localVarQueryParams.Add("step", parameterToString(*r.step, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xFields != nil {
		localVarHeaderParams["X-Fields"] = parameterToString(*r.xFields, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
